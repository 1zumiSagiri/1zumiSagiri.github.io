---
layout: about
title: about
permalink: /
subtitle: Undergraduate Computer Science, <a href='https://engineering.buffalo.edu/computer-science-engineering.html'>University at Buffalo</a>.

profile:
  align: right
  image: prof_pic.jpg
  image_circular: false # crops the image to make it circular
  more_info: >
    <p>12 Capen Hall</p>
    <p>Buffalo, New York 14260</p>

news: false # includes a list of news items
selected_papers: false # includes a list of papers marked as "selected={true}"
social: true # includes social icons at the bottom of the page
---

Pretty sure most of the people came to this site via [CSE331 Algorithms and Complexity webpage](https://www-student.cse.buffalo.edu/~atri/cse331/fall24/policies/syllabus.html). After completing this course, whenever I was exposed to the various more in-depth topics in computer science (most 400+ level courses), I found that they were always accompanied by math, algorithms, and proofs. My experience with CSE 331 made reading them less painful, and made me realize the importance of logical thinking in science. I also find that I spend more time thinking when writing code. As a result, there are fewer mistakes, and it's easier to find them in code.

I am also TA for CSE305 Introduction to Programming Languages. Some people might argue why they should learn OCaml, some people can't clearly state what functional programming is until the end of the course (me too!). But I think learning a programming language from a functional programming perspective is interesting. Because the programming paradigm is so different from imperative languages, it always reminds me of when I took my first CS course, and everything was new to me, and that's great. After I learned about these abstract concepts in programming languages, I found it easier to learn modern languages such as modern C++ and Rust.
